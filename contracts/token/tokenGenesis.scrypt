import "tokenProto.scrypt";
import "../protoheader.scrypt";
import "../backtrace.scrypt";

contract TokenGenesis {

    public function unlock(
        SigHashPreimage txPreimage,
        PubKey pubKey,
        Sig sig,
        bytes tokenScript,
        // genesisTx input proof
        bytes genesisTxHeader,
        int prevInputIndex,
        TxInputProof genesisTxInputProof,
        // prev genesis tx output proof
        bytes prevGenesisTxHeader,
        bytes prevTxOutputHashProof,
        bytes prevTxOutputSatoshiBytes,
        // output
        int genesisSatoshis,
        int tokenSatoshis,
        Ripemd160 changeAddress,
        int changeSatoshis,
        bytes opReturnScript) {

        // verify this tx's version
        require(Utils.fromLEUnsigned(SigHash.nVersion(txPreimage)) == ProtoHeader.TX_VERSION);

        // check input script oracle data
        bytes genesisScript = SigHash.scriptCode(txPreimage);
        int genesisScriptLen = len(genesisScript);

        int tokenValue = TokenProto.getTokenAmount(genesisScript, genesisScriptLen);
        require(tokenValue == 0);
        require(TokenProto.getGenesisHash(genesisScript, genesisScriptLen) == b'0000000000000000000000000000000000000000');
        bytes sensibleID = TokenProto.getSensibleID(genesisScript, genesisScriptLen);
        bool isFirst = false;
        bytes thisOutpoint = SigHash.outpoint(txPreimage);
        if (sensibleID == b'000000000000000000000000000000000000000000000000000000000000000000000000') {
            isFirst = true;
            sensibleID = thisOutpoint;
        }
        require(TokenProto.checkProtoHeader(genesisScript, genesisScriptLen));
        // check opreturn
        require(TokenProto.checkDataLen(genesisScript, genesisScriptLen));

        if (!isFirst) {
            // backtrace to genesis script
            bytes prevScriptHash = sha256(genesisScript);
            TxOutputProof prevGenesisTxProof = {prevGenesisTxHeader, prevTxOutputHashProof, prevTxOutputSatoshiBytes, prevScriptHash};
            Backtrace.verify(thisOutpoint, genesisTxHeader, prevInputIndex, prevGenesisTxProof, sensibleID, genesisTxInputProof);
        }

        // genesisHash
        bytes newGenesisScript = TokenProto.getNewGenesisScript(genesisScript, genesisScriptLen, sensibleID);
        bytes genesisHash = hash160(newGenesisScript);

        // check tokenScript oracle data
        int tokenScriptLen = len(tokenScript);

        require(sensibleID == TokenProto.getSensibleID(tokenScript, tokenScriptLen));
        require(genesisHash == TokenProto.getGenesisHash(tokenScript, tokenScriptLen));
        // check data part
        require(TokenProto.checkDataLen(tokenScript, tokenScriptLen));

        bytes genesisOutput = b'';
        if (genesisSatoshis > 0) {
            genesisOutput = Utils.buildOutput(newGenesisScript, genesisSatoshis);
        }
        bytes tokenOutput = Utils.buildOutput(tokenScript, tokenSatoshis);

        // op_false op_return output
        bytes opReturnOutput = b'';
        if (len(opReturnScript) > 0) {
            require(opReturnScript[0 : 2] == b'006a');
            opReturnOutput = Utils.buildOutput(opReturnScript, 0);
        }

        // bsv change output
        bytes changeOutput = TxUtil.genBsvOutput(changeSatoshis, changeAddress);

        bytes hashOutput = hash256(genesisOutput + tokenOutput + opReturnOutput + changeOutput);
        require(hashOutput == SigHash.hashOutputs(txPreimage));

        // check sig
        bytes senderAddress = TokenProto.getTokenAddress(genesisScript, genesisScriptLen);
        require(senderAddress == hash160(pubKey));
        require(checkSig(sig, pubKey));

        require(Tx.checkPreimageSigHashType(txPreimage, ProtoHeader.SIG_HASH_ALL));
    }
}
